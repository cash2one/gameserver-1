// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "client.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace PublicProto {

namespace {

const ::google::protobuf::Descriptor* AccountAndTokenToServer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountAndTokenToServer_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_ClientLoginReady_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_ClientLoginReady_reflection_ = NULL;
const ::google::protobuf::Descriptor* C_SetUpName_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  C_SetUpName_reflection_ = NULL;
const ::google::protobuf::Descriptor* C_MoveTo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  C_MoveTo_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_ItemRoleInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_ItemRoleInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_ItemFoodInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_ItemFoodInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_ItemThronInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_ItemThronInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_ItemBulletInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_ItemBulletInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_ItemCollapsar_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_ItemCollapsar_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_SyncSceneInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_SyncSceneInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* SceneItemAttr_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SceneItemAttr_reflection_ = NULL;
const ::google::protobuf::Descriptor* HighSpeedSceneItemAttr_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HighSpeedSceneItemAttr_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_SyncLogicCenter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_SyncLogicCenter_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_GameOver_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_GameOver_reflection_ = NULL;
const ::google::protobuf::Descriptor* C_Fission_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  C_Fission_reflection_ = NULL;
const ::google::protobuf::Descriptor* C_Expal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  C_Expal_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_UserLogout_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_UserLogout_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_SceneItemAttrAfterImpactToCollapsar_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_SceneItemAttrAfterImpactToCollapsar_reflection_ = NULL;
const ::google::protobuf::Descriptor* S_UpdatePoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  S_UpdatePoint_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_client_2eproto() {
  protobuf_AddDesc_client_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "client.proto");
  GOOGLE_CHECK(file != NULL);
  AccountAndTokenToServer_descriptor_ = file->message_type(0);
  static const int AccountAndTokenToServer_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAndTokenToServer, acc_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAndTokenToServer, token_),
  };
  AccountAndTokenToServer_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AccountAndTokenToServer_descriptor_,
      AccountAndTokenToServer::default_instance_,
      AccountAndTokenToServer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAndTokenToServer, _has_bits_[0]),
      -1,
      -1,
      sizeof(AccountAndTokenToServer),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountAndTokenToServer, _internal_metadata_),
      -1);
  S_ClientLoginReady_descriptor_ = file->message_type(1);
  static const int S_ClientLoginReady_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ClientLoginReady, uid_),
  };
  S_ClientLoginReady_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_ClientLoginReady_descriptor_,
      S_ClientLoginReady::default_instance_,
      S_ClientLoginReady_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ClientLoginReady, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_ClientLoginReady),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ClientLoginReady, _internal_metadata_),
      -1);
  C_SetUpName_descriptor_ = file->message_type(2);
  static const int C_SetUpName_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_SetUpName, name_),
  };
  C_SetUpName_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      C_SetUpName_descriptor_,
      C_SetUpName::default_instance_,
      C_SetUpName_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_SetUpName, _has_bits_[0]),
      -1,
      -1,
      sizeof(C_SetUpName),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_SetUpName, _internal_metadata_),
      -1);
  C_MoveTo_descriptor_ = file->message_type(3);
  static const int C_MoveTo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_MoveTo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_MoveTo, y_),
  };
  C_MoveTo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      C_MoveTo_descriptor_,
      C_MoveTo::default_instance_,
      C_MoveTo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_MoveTo, _has_bits_[0]),
      -1,
      -1,
      sizeof(C_MoveTo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_MoveTo, _internal_metadata_),
      -1);
  S_ItemRoleInfo_descriptor_ = file->message_type(4);
  static const int S_ItemRoleInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, color_),
  };
  S_ItemRoleInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_ItemRoleInfo_descriptor_,
      S_ItemRoleInfo::default_instance_,
      S_ItemRoleInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_ItemRoleInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemRoleInfo, _internal_metadata_),
      -1);
  S_ItemFoodInfo_descriptor_ = file->message_type(5);
  static const int S_ItemFoodInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemFoodInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemFoodInfo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemFoodInfo, y_),
  };
  S_ItemFoodInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_ItemFoodInfo_descriptor_,
      S_ItemFoodInfo::default_instance_,
      S_ItemFoodInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemFoodInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_ItemFoodInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemFoodInfo, _internal_metadata_),
      -1);
  S_ItemThronInfo_descriptor_ = file->message_type(6);
  static const int S_ItemThronInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemThronInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemThronInfo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemThronInfo, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemThronInfo, radius_),
  };
  S_ItemThronInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_ItemThronInfo_descriptor_,
      S_ItemThronInfo::default_instance_,
      S_ItemThronInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemThronInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_ItemThronInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemThronInfo, _internal_metadata_),
      -1);
  S_ItemBulletInfo_descriptor_ = file->message_type(7);
  static const int S_ItemBulletInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemBulletInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemBulletInfo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemBulletInfo, y_),
  };
  S_ItemBulletInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_ItemBulletInfo_descriptor_,
      S_ItemBulletInfo::default_instance_,
      S_ItemBulletInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemBulletInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_ItemBulletInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemBulletInfo, _internal_metadata_),
      -1);
  S_ItemCollapsar_descriptor_ = file->message_type(8);
  static const int S_ItemCollapsar_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemCollapsar, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemCollapsar, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemCollapsar, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemCollapsar, radius_),
  };
  S_ItemCollapsar_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_ItemCollapsar_descriptor_,
      S_ItemCollapsar::default_instance_,
      S_ItemCollapsar_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemCollapsar, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_ItemCollapsar),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_ItemCollapsar, _internal_metadata_),
      -1);
  S_SyncSceneInfo_descriptor_ = file->message_type(9);
  static const int S_SyncSceneInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, roles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, foods_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, throns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, bullets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, collapsar_),
  };
  S_SyncSceneInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_SyncSceneInfo_descriptor_,
      S_SyncSceneInfo::default_instance_,
      S_SyncSceneInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_SyncSceneInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncSceneInfo, _internal_metadata_),
      -1);
  SceneItemAttr_descriptor_ = file->message_type(10);
  static const int SceneItemAttr_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneItemAttr, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneItemAttr, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneItemAttr, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneItemAttr, y_),
  };
  SceneItemAttr_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SceneItemAttr_descriptor_,
      SceneItemAttr::default_instance_,
      SceneItemAttr_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneItemAttr, _has_bits_[0]),
      -1,
      -1,
      sizeof(SceneItemAttr),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SceneItemAttr, _internal_metadata_),
      -1);
  HighSpeedSceneItemAttr_descriptor_ = file->message_type(11);
  static const int HighSpeedSceneItemAttr_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighSpeedSceneItemAttr, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighSpeedSceneItemAttr, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighSpeedSceneItemAttr, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighSpeedSceneItemAttr, y_),
  };
  HighSpeedSceneItemAttr_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HighSpeedSceneItemAttr_descriptor_,
      HighSpeedSceneItemAttr::default_instance_,
      HighSpeedSceneItemAttr_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighSpeedSceneItemAttr, _has_bits_[0]),
      -1,
      -1,
      sizeof(HighSpeedSceneItemAttr),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HighSpeedSceneItemAttr, _internal_metadata_),
      -1);
  DeleteItem_descriptor_ = file->message_type(12);
  static const int DeleteItem_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteItem, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteItem, predator_id_),
  };
  DeleteItem_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteItem_descriptor_,
      DeleteItem::default_instance_,
      DeleteItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteItem, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteItem),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteItem, _internal_metadata_),
      -1);
  S_SyncLogicCenter_descriptor_ = file->message_type(13);
  static const int S_SyncLogicCenter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncLogicCenter, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncLogicCenter, y_),
  };
  S_SyncLogicCenter_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_SyncLogicCenter_descriptor_,
      S_SyncLogicCenter::default_instance_,
      S_SyncLogicCenter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncLogicCenter, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_SyncLogicCenter),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SyncLogicCenter, _internal_metadata_),
      -1);
  S_GameOver_descriptor_ = file->message_type(14);
  static const int S_GameOver_offsets_[1] = {
  };
  S_GameOver_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_GameOver_descriptor_,
      S_GameOver::default_instance_,
      S_GameOver_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_GameOver, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_GameOver),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_GameOver, _internal_metadata_),
      -1);
  C_Fission_descriptor_ = file->message_type(15);
  static const int C_Fission_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_Fission, radian_),
  };
  C_Fission_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      C_Fission_descriptor_,
      C_Fission::default_instance_,
      C_Fission_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_Fission, _has_bits_[0]),
      -1,
      -1,
      sizeof(C_Fission),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_Fission, _internal_metadata_),
      -1);
  C_Expal_descriptor_ = file->message_type(16);
  static const int C_Expal_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_Expal, radian_),
  };
  C_Expal_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      C_Expal_descriptor_,
      C_Expal::default_instance_,
      C_Expal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_Expal, _has_bits_[0]),
      -1,
      -1,
      sizeof(C_Expal),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(C_Expal, _internal_metadata_),
      -1);
  S_UserLogout_descriptor_ = file->message_type(17);
  static const int S_UserLogout_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_UserLogout, uid_),
  };
  S_UserLogout_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_UserLogout_descriptor_,
      S_UserLogout::default_instance_,
      S_UserLogout_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_UserLogout, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_UserLogout),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_UserLogout, _internal_metadata_),
      -1);
  S_SceneItemAttrAfterImpactToCollapsar_descriptor_ = file->message_type(18);
  static const int S_SceneItemAttrAfterImpactToCollapsar_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SceneItemAttrAfterImpactToCollapsar, new_pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SceneItemAttrAfterImpactToCollapsar, collapsar_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SceneItemAttrAfterImpactToCollapsar, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SceneItemAttrAfterImpactToCollapsar, erase_collapsar_),
  };
  S_SceneItemAttrAfterImpactToCollapsar_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_SceneItemAttrAfterImpactToCollapsar_descriptor_,
      S_SceneItemAttrAfterImpactToCollapsar::default_instance_,
      S_SceneItemAttrAfterImpactToCollapsar_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SceneItemAttrAfterImpactToCollapsar, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_SceneItemAttrAfterImpactToCollapsar),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_SceneItemAttrAfterImpactToCollapsar, _internal_metadata_),
      -1);
  S_UpdatePoint_descriptor_ = file->message_type(19);
  static const int S_UpdatePoint_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_UpdatePoint, point_),
  };
  S_UpdatePoint_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      S_UpdatePoint_descriptor_,
      S_UpdatePoint::default_instance_,
      S_UpdatePoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_UpdatePoint, _has_bits_[0]),
      -1,
      -1,
      sizeof(S_UpdatePoint),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(S_UpdatePoint, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_client_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AccountAndTokenToServer_descriptor_, &AccountAndTokenToServer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_ClientLoginReady_descriptor_, &S_ClientLoginReady::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      C_SetUpName_descriptor_, &C_SetUpName::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      C_MoveTo_descriptor_, &C_MoveTo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_ItemRoleInfo_descriptor_, &S_ItemRoleInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_ItemFoodInfo_descriptor_, &S_ItemFoodInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_ItemThronInfo_descriptor_, &S_ItemThronInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_ItemBulletInfo_descriptor_, &S_ItemBulletInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_ItemCollapsar_descriptor_, &S_ItemCollapsar::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_SyncSceneInfo_descriptor_, &S_SyncSceneInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SceneItemAttr_descriptor_, &SceneItemAttr::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HighSpeedSceneItemAttr_descriptor_, &HighSpeedSceneItemAttr::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteItem_descriptor_, &DeleteItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_SyncLogicCenter_descriptor_, &S_SyncLogicCenter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_GameOver_descriptor_, &S_GameOver::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      C_Fission_descriptor_, &C_Fission::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      C_Expal_descriptor_, &C_Expal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_UserLogout_descriptor_, &S_UserLogout::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_SceneItemAttrAfterImpactToCollapsar_descriptor_, &S_SceneItemAttrAfterImpactToCollapsar::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      S_UpdatePoint_descriptor_, &S_UpdatePoint::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_client_2eproto() {
  delete AccountAndTokenToServer::default_instance_;
  delete AccountAndTokenToServer_reflection_;
  delete S_ClientLoginReady::default_instance_;
  delete S_ClientLoginReady_reflection_;
  delete C_SetUpName::default_instance_;
  delete C_SetUpName_reflection_;
  delete C_MoveTo::default_instance_;
  delete C_MoveTo_reflection_;
  delete S_ItemRoleInfo::default_instance_;
  delete S_ItemRoleInfo_reflection_;
  delete S_ItemFoodInfo::default_instance_;
  delete S_ItemFoodInfo_reflection_;
  delete S_ItemThronInfo::default_instance_;
  delete S_ItemThronInfo_reflection_;
  delete S_ItemBulletInfo::default_instance_;
  delete S_ItemBulletInfo_reflection_;
  delete S_ItemCollapsar::default_instance_;
  delete S_ItemCollapsar_reflection_;
  delete S_SyncSceneInfo::default_instance_;
  delete S_SyncSceneInfo_reflection_;
  delete SceneItemAttr::default_instance_;
  delete SceneItemAttr_reflection_;
  delete HighSpeedSceneItemAttr::default_instance_;
  delete HighSpeedSceneItemAttr_reflection_;
  delete DeleteItem::default_instance_;
  delete DeleteItem_reflection_;
  delete S_SyncLogicCenter::default_instance_;
  delete S_SyncLogicCenter_reflection_;
  delete S_GameOver::default_instance_;
  delete S_GameOver_reflection_;
  delete C_Fission::default_instance_;
  delete C_Fission_reflection_;
  delete C_Expal::default_instance_;
  delete C_Expal_reflection_;
  delete S_UserLogout::default_instance_;
  delete S_UserLogout_reflection_;
  delete S_SceneItemAttrAfterImpactToCollapsar::default_instance_;
  delete S_SceneItemAttrAfterImpactToCollapsar_reflection_;
  delete S_UpdatePoint::default_instance_;
  delete S_UpdatePoint_reflection_;
}

void protobuf_AddDesc_client_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014client.proto\022\013PublicProto\"8\n\027AccountAn"
    "dTokenToServer\022\016\n\006acc_id\030\001 \002(\004\022\r\n\005token\030"
    "\002 \002(\004\"!\n\022S_ClientLoginReady\022\013\n\003uid\030\001 \002(\004"
    "\"\033\n\013C_SetUpName\022\014\n\004name\030\001 \002(\t\" \n\010C_MoveT"
    "o\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\"l\n\016S_ItemRoleInf"
    "o\022\n\n\002id\030\001 \002(\r\022\t\n\001x\030\002 \002(\002\022\t\n\001y\030\003 \002(\002\022\016\n\006r"
    "adius\030\004 \002(\005\022\014\n\004name\030\005 \001(\t\022\013\n\003uid\030\006 \002(\004\022\r"
    "\n\005color\030\007 \002(\005\"2\n\016S_ItemFoodInfo\022\n\n\002id\030\001 "
    "\002(\r\022\t\n\001x\030\002 \002(\002\022\t\n\001y\030\003 \002(\002\"C\n\017S_ItemThron"
    "Info\022\n\n\002id\030\001 \002(\r\022\t\n\001x\030\002 \002(\002\022\t\n\001y\030\003 \002(\002\022\016"
    "\n\006radius\030\004 \002(\005\"4\n\020S_ItemBulletInfo\022\n\n\002id"
    "\030\001 \002(\r\022\t\n\001x\030\002 \002(\002\022\t\n\001y\030\003 \002(\002\"C\n\017S_ItemCo"
    "llapsar\022\n\n\002id\030\001 \002(\r\022\t\n\001x\030\002 \002(\002\022\t\n\001y\030\003 \002("
    "\002\022\016\n\006radius\030\005 \002(\005\"\370\001\n\017S_SyncSceneInfo\022*\n"
    "\005roles\030\001 \003(\0132\033.PublicProto.S_ItemRoleInf"
    "o\022*\n\005foods\030\002 \003(\0132\033.PublicProto.S_ItemFoo"
    "dInfo\022,\n\006throns\030\003 \003(\0132\034.PublicProto.S_It"
    "emThronInfo\022.\n\007bullets\030\004 \003(\0132\035.PublicPro"
    "to.S_ItemBulletInfo\022/\n\tcollapsar\030\005 \003(\0132\034"
    ".PublicProto.S_ItemCollapsar\"A\n\rSceneIte"
    "mAttr\022\n\n\002id\030\001 \002(\r\022\016\n\006radius\030\002 \001(\005\022\t\n\001x\030\003"
    " \001(\002\022\t\n\001y\030\004 \001(\002\"J\n\026HighSpeedSceneItemAtt"
    "r\022\n\n\002id\030\001 \002(\r\022\016\n\006radius\030\002 \001(\005\022\t\n\001x\030\003 \001(\002"
    "\022\t\n\001y\030\004 \001(\002\"-\n\nDeleteItem\022\n\n\002id\030\001 \002(\r\022\023\n"
    "\013predator_id\030\002 \001(\r\")\n\021S_SyncLogicCenter\022"
    "\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\"\014\n\nS_GameOver\"\033\n\tC"
    "_Fission\022\016\n\006radian\030\001 \002(\002\"\031\n\007C_Expal\022\016\n\006r"
    "adian\030\001 \002(\002\"\033\n\014S_UserLogout\022\013\n\003uid\030\001 \002(\004"
    "\"\220\001\n%S_SceneItemAttrAfterImpactToCollaps"
    "ar\022+\n\007new_pos\030\001 \003(\0132\032.PublicProto.SceneI"
    "temAttr\022\024\n\014collapsar_id\030\002 \002(\r\022\013\n\003uid\030\003 \002"
    "(\004\022\027\n\017erase_collapsar\030\004 \002(\010\"\036\n\rS_UpdateP"
    "oint\022\r\n\005point\030\001 \002(\r", 1299);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "client.proto", &protobuf_RegisterTypes);
  AccountAndTokenToServer::default_instance_ = new AccountAndTokenToServer();
  S_ClientLoginReady::default_instance_ = new S_ClientLoginReady();
  C_SetUpName::default_instance_ = new C_SetUpName();
  C_MoveTo::default_instance_ = new C_MoveTo();
  S_ItemRoleInfo::default_instance_ = new S_ItemRoleInfo();
  S_ItemFoodInfo::default_instance_ = new S_ItemFoodInfo();
  S_ItemThronInfo::default_instance_ = new S_ItemThronInfo();
  S_ItemBulletInfo::default_instance_ = new S_ItemBulletInfo();
  S_ItemCollapsar::default_instance_ = new S_ItemCollapsar();
  S_SyncSceneInfo::default_instance_ = new S_SyncSceneInfo();
  SceneItemAttr::default_instance_ = new SceneItemAttr();
  HighSpeedSceneItemAttr::default_instance_ = new HighSpeedSceneItemAttr();
  DeleteItem::default_instance_ = new DeleteItem();
  S_SyncLogicCenter::default_instance_ = new S_SyncLogicCenter();
  S_GameOver::default_instance_ = new S_GameOver();
  C_Fission::default_instance_ = new C_Fission();
  C_Expal::default_instance_ = new C_Expal();
  S_UserLogout::default_instance_ = new S_UserLogout();
  S_SceneItemAttrAfterImpactToCollapsar::default_instance_ = new S_SceneItemAttrAfterImpactToCollapsar();
  S_UpdatePoint::default_instance_ = new S_UpdatePoint();
  AccountAndTokenToServer::default_instance_->InitAsDefaultInstance();
  S_ClientLoginReady::default_instance_->InitAsDefaultInstance();
  C_SetUpName::default_instance_->InitAsDefaultInstance();
  C_MoveTo::default_instance_->InitAsDefaultInstance();
  S_ItemRoleInfo::default_instance_->InitAsDefaultInstance();
  S_ItemFoodInfo::default_instance_->InitAsDefaultInstance();
  S_ItemThronInfo::default_instance_->InitAsDefaultInstance();
  S_ItemBulletInfo::default_instance_->InitAsDefaultInstance();
  S_ItemCollapsar::default_instance_->InitAsDefaultInstance();
  S_SyncSceneInfo::default_instance_->InitAsDefaultInstance();
  SceneItemAttr::default_instance_->InitAsDefaultInstance();
  HighSpeedSceneItemAttr::default_instance_->InitAsDefaultInstance();
  DeleteItem::default_instance_->InitAsDefaultInstance();
  S_SyncLogicCenter::default_instance_->InitAsDefaultInstance();
  S_GameOver::default_instance_->InitAsDefaultInstance();
  C_Fission::default_instance_->InitAsDefaultInstance();
  C_Expal::default_instance_->InitAsDefaultInstance();
  S_UserLogout::default_instance_->InitAsDefaultInstance();
  S_SceneItemAttrAfterImpactToCollapsar::default_instance_->InitAsDefaultInstance();
  S_UpdatePoint::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_client_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_client_2eproto {
  StaticDescriptorInitializer_client_2eproto() {
    protobuf_AddDesc_client_2eproto();
  }
} static_descriptor_initializer_client_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int AccountAndTokenToServer::kAccIdFieldNumber;
const int AccountAndTokenToServer::kTokenFieldNumber;
#endif  // !_MSC_VER

AccountAndTokenToServer::AccountAndTokenToServer()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.AccountAndTokenToServer)
}

void AccountAndTokenToServer::InitAsDefaultInstance() {
}

AccountAndTokenToServer::AccountAndTokenToServer(const AccountAndTokenToServer& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.AccountAndTokenToServer)
}

void AccountAndTokenToServer::SharedCtor() {
  _cached_size_ = 0;
  acc_id_ = GOOGLE_ULONGLONG(0);
  token_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountAndTokenToServer::~AccountAndTokenToServer() {
  // @@protoc_insertion_point(destructor:PublicProto.AccountAndTokenToServer)
  SharedDtor();
}

void AccountAndTokenToServer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AccountAndTokenToServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountAndTokenToServer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountAndTokenToServer_descriptor_;
}

const AccountAndTokenToServer& AccountAndTokenToServer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

AccountAndTokenToServer* AccountAndTokenToServer::default_instance_ = NULL;

AccountAndTokenToServer* AccountAndTokenToServer::New(::google::protobuf::Arena* arena) const {
  AccountAndTokenToServer* n = new AccountAndTokenToServer;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AccountAndTokenToServer::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AccountAndTokenToServer*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(acc_id_, token_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AccountAndTokenToServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.AccountAndTokenToServer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 acc_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &acc_id_)));
          set_has_acc_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_token;
        break;
      }

      // required uint64 token = 2;
      case 2: {
        if (tag == 16) {
         parse_token:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.AccountAndTokenToServer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.AccountAndTokenToServer)
  return false;
#undef DO_
}

void AccountAndTokenToServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.AccountAndTokenToServer)
  // required uint64 acc_id = 1;
  if (has_acc_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->acc_id(), output);
  }

  // required uint64 token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->token(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.AccountAndTokenToServer)
}

::google::protobuf::uint8* AccountAndTokenToServer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.AccountAndTokenToServer)
  // required uint64 acc_id = 1;
  if (has_acc_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->acc_id(), target);
  }

  // required uint64 token = 2;
  if (has_token()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->token(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.AccountAndTokenToServer)
  return target;
}

int AccountAndTokenToServer::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_acc_id()) {
    // required uint64 acc_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->acc_id());
  }

  if (has_token()) {
    // required uint64 token = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->token());
  }

  return total_size;
}
int AccountAndTokenToServer::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 acc_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->acc_id());

    // required uint64 token = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->token());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountAndTokenToServer::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AccountAndTokenToServer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountAndTokenToServer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountAndTokenToServer::MergeFrom(const AccountAndTokenToServer& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_acc_id()) {
      set_acc_id(from.acc_id());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AccountAndTokenToServer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountAndTokenToServer::CopyFrom(const AccountAndTokenToServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAndTokenToServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AccountAndTokenToServer::Swap(AccountAndTokenToServer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AccountAndTokenToServer::InternalSwap(AccountAndTokenToServer* other) {
  std::swap(acc_id_, other->acc_id_);
  std::swap(token_, other->token_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AccountAndTokenToServer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountAndTokenToServer_descriptor_;
  metadata.reflection = AccountAndTokenToServer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_ClientLoginReady::kUidFieldNumber;
#endif  // !_MSC_VER

S_ClientLoginReady::S_ClientLoginReady()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_ClientLoginReady)
}

void S_ClientLoginReady::InitAsDefaultInstance() {
}

S_ClientLoginReady::S_ClientLoginReady(const S_ClientLoginReady& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_ClientLoginReady)
}

void S_ClientLoginReady::SharedCtor() {
  _cached_size_ = 0;
  uid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_ClientLoginReady::~S_ClientLoginReady() {
  // @@protoc_insertion_point(destructor:PublicProto.S_ClientLoginReady)
  SharedDtor();
}

void S_ClientLoginReady::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_ClientLoginReady::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_ClientLoginReady::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_ClientLoginReady_descriptor_;
}

const S_ClientLoginReady& S_ClientLoginReady::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_ClientLoginReady* S_ClientLoginReady::default_instance_ = NULL;

S_ClientLoginReady* S_ClientLoginReady::New(::google::protobuf::Arena* arena) const {
  S_ClientLoginReady* n = new S_ClientLoginReady;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_ClientLoginReady::Clear() {
  uid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_ClientLoginReady::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_ClientLoginReady)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 uid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_ClientLoginReady)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_ClientLoginReady)
  return false;
#undef DO_
}

void S_ClientLoginReady::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_ClientLoginReady)
  // required uint64 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_ClientLoginReady)
}

::google::protobuf::uint8* S_ClientLoginReady::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_ClientLoginReady)
  // required uint64 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->uid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_ClientLoginReady)
  return target;
}

int S_ClientLoginReady::ByteSize() const {
  int total_size = 0;

  // required uint64 uid = 1;
  if (has_uid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->uid());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_ClientLoginReady::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_ClientLoginReady* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_ClientLoginReady*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_ClientLoginReady::MergeFrom(const S_ClientLoginReady& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_ClientLoginReady::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_ClientLoginReady::CopyFrom(const S_ClientLoginReady& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ClientLoginReady::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void S_ClientLoginReady::Swap(S_ClientLoginReady* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_ClientLoginReady::InternalSwap(S_ClientLoginReady* other) {
  std::swap(uid_, other->uid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_ClientLoginReady::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_ClientLoginReady_descriptor_;
  metadata.reflection = S_ClientLoginReady_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int C_SetUpName::kNameFieldNumber;
#endif  // !_MSC_VER

C_SetUpName::C_SetUpName()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.C_SetUpName)
}

void C_SetUpName::InitAsDefaultInstance() {
}

C_SetUpName::C_SetUpName(const C_SetUpName& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.C_SetUpName)
}

void C_SetUpName::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

C_SetUpName::~C_SetUpName() {
  // @@protoc_insertion_point(destructor:PublicProto.C_SetUpName)
  SharedDtor();
}

void C_SetUpName::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void C_SetUpName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* C_SetUpName::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return C_SetUpName_descriptor_;
}

const C_SetUpName& C_SetUpName::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

C_SetUpName* C_SetUpName::default_instance_ = NULL;

C_SetUpName* C_SetUpName::New(::google::protobuf::Arena* arena) const {
  C_SetUpName* n = new C_SetUpName;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void C_SetUpName::Clear() {
  if (has_name()) {
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool C_SetUpName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.C_SetUpName)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "PublicProto.C_SetUpName.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.C_SetUpName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.C_SetUpName)
  return false;
#undef DO_
}

void C_SetUpName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.C_SetUpName)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "PublicProto.C_SetUpName.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.C_SetUpName)
}

::google::protobuf::uint8* C_SetUpName::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.C_SetUpName)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "PublicProto.C_SetUpName.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.C_SetUpName)
  return target;
}

int C_SetUpName::ByteSize() const {
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void C_SetUpName::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const C_SetUpName* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const C_SetUpName*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void C_SetUpName::MergeFrom(const C_SetUpName& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void C_SetUpName::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void C_SetUpName::CopyFrom(const C_SetUpName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_SetUpName::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void C_SetUpName::Swap(C_SetUpName* other) {
  if (other == this) return;
  InternalSwap(other);
}
void C_SetUpName::InternalSwap(C_SetUpName* other) {
  name_.Swap(&other->name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata C_SetUpName::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = C_SetUpName_descriptor_;
  metadata.reflection = C_SetUpName_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int C_MoveTo::kXFieldNumber;
const int C_MoveTo::kYFieldNumber;
#endif  // !_MSC_VER

C_MoveTo::C_MoveTo()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.C_MoveTo)
}

void C_MoveTo::InitAsDefaultInstance() {
}

C_MoveTo::C_MoveTo(const C_MoveTo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.C_MoveTo)
}

void C_MoveTo::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

C_MoveTo::~C_MoveTo() {
  // @@protoc_insertion_point(destructor:PublicProto.C_MoveTo)
  SharedDtor();
}

void C_MoveTo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void C_MoveTo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* C_MoveTo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return C_MoveTo_descriptor_;
}

const C_MoveTo& C_MoveTo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

C_MoveTo* C_MoveTo::default_instance_ = NULL;

C_MoveTo* C_MoveTo::New(::google::protobuf::Arena* arena) const {
  C_MoveTo* n = new C_MoveTo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void C_MoveTo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<C_MoveTo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool C_MoveTo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.C_MoveTo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.C_MoveTo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.C_MoveTo)
  return false;
#undef DO_
}

void C_MoveTo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.C_MoveTo)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.C_MoveTo)
}

::google::protobuf::uint8* C_MoveTo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.C_MoveTo)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.C_MoveTo)
  return target;
}

int C_MoveTo::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
int C_MoveTo::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void C_MoveTo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const C_MoveTo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const C_MoveTo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void C_MoveTo::MergeFrom(const C_MoveTo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void C_MoveTo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void C_MoveTo::CopyFrom(const C_MoveTo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_MoveTo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void C_MoveTo::Swap(C_MoveTo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void C_MoveTo::InternalSwap(C_MoveTo* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata C_MoveTo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = C_MoveTo_descriptor_;
  metadata.reflection = C_MoveTo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_ItemRoleInfo::kIdFieldNumber;
const int S_ItemRoleInfo::kXFieldNumber;
const int S_ItemRoleInfo::kYFieldNumber;
const int S_ItemRoleInfo::kRadiusFieldNumber;
const int S_ItemRoleInfo::kNameFieldNumber;
const int S_ItemRoleInfo::kUidFieldNumber;
const int S_ItemRoleInfo::kColorFieldNumber;
#endif  // !_MSC_VER

S_ItemRoleInfo::S_ItemRoleInfo()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_ItemRoleInfo)
}

void S_ItemRoleInfo::InitAsDefaultInstance() {
}

S_ItemRoleInfo::S_ItemRoleInfo(const S_ItemRoleInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_ItemRoleInfo)
}

void S_ItemRoleInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0u;
  x_ = 0;
  y_ = 0;
  radius_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = GOOGLE_ULONGLONG(0);
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_ItemRoleInfo::~S_ItemRoleInfo() {
  // @@protoc_insertion_point(destructor:PublicProto.S_ItemRoleInfo)
  SharedDtor();
}

void S_ItemRoleInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void S_ItemRoleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_ItemRoleInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_ItemRoleInfo_descriptor_;
}

const S_ItemRoleInfo& S_ItemRoleInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_ItemRoleInfo* S_ItemRoleInfo::default_instance_ = NULL;

S_ItemRoleInfo* S_ItemRoleInfo::New(::google::protobuf::Arena* arena) const {
  S_ItemRoleInfo* n = new S_ItemRoleInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_ItemRoleInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_ItemRoleInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(id_, radius_);
    ZR_(uid_, color_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_ItemRoleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_ItemRoleInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // required float x = 2;
      case 2: {
        if (tag == 21) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // required float y = 3;
      case 3: {
        if (tag == 29) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_radius;
        break;
      }

      // required int32 radius = 4;
      case 4: {
        if (tag == 32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }

      // optional string name = 5;
      case 5: {
        if (tag == 42) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "PublicProto.S_ItemRoleInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_uid;
        break;
      }

      // required uint64 uid = 6;
      case 6: {
        if (tag == 48) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_color;
        break;
      }

      // required int32 color = 7;
      case 7: {
        if (tag == 56) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_ItemRoleInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_ItemRoleInfo)
  return false;
#undef DO_
}

void S_ItemRoleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_ItemRoleInfo)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required float x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // required float y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->y(), output);
  }

  // required int32 radius = 4;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->radius(), output);
  }

  // optional string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "PublicProto.S_ItemRoleInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->name(), output);
  }

  // required uint64 uid = 6;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->uid(), output);
  }

  // required int32 color = 7;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->color(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_ItemRoleInfo)
}

::google::protobuf::uint8* S_ItemRoleInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_ItemRoleInfo)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required float x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // required float y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->y(), target);
  }

  // required int32 radius = 4;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->radius(), target);
  }

  // optional string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "PublicProto.S_ItemRoleInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->name(), target);
  }

  // required uint64 uid = 6;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->uid(), target);
  }

  // required int32 color = 7;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->color(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_ItemRoleInfo)
  return target;
}

int S_ItemRoleInfo::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  if (has_x()) {
    // required float x = 2;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 3;
    total_size += 1 + 4;
  }

  if (has_radius()) {
    // required int32 radius = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->radius());
  }

  if (has_uid()) {
    // required uint64 uid = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->uid());
  }

  if (has_color()) {
    // required int32 color = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->color());
  }

  return total_size;
}
int S_ItemRoleInfo::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000006f) ^ 0x0000006f) == 0) {  // All required fields are present.
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());

    // required float x = 2;
    total_size += 1 + 4;

    // required float y = 3;
    total_size += 1 + 4;

    // required int32 radius = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->radius());

    // required uint64 uid = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->uid());

    // required int32 color = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->color());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string name = 5;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_ItemRoleInfo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_ItemRoleInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_ItemRoleInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_ItemRoleInfo::MergeFrom(const S_ItemRoleInfo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_ItemRoleInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_ItemRoleInfo::CopyFrom(const S_ItemRoleInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ItemRoleInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000006f) != 0x0000006f) return false;

  return true;
}

void S_ItemRoleInfo::Swap(S_ItemRoleInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_ItemRoleInfo::InternalSwap(S_ItemRoleInfo* other) {
  std::swap(id_, other->id_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(radius_, other->radius_);
  name_.Swap(&other->name_);
  std::swap(uid_, other->uid_);
  std::swap(color_, other->color_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_ItemRoleInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_ItemRoleInfo_descriptor_;
  metadata.reflection = S_ItemRoleInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_ItemFoodInfo::kIdFieldNumber;
const int S_ItemFoodInfo::kXFieldNumber;
const int S_ItemFoodInfo::kYFieldNumber;
#endif  // !_MSC_VER

S_ItemFoodInfo::S_ItemFoodInfo()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_ItemFoodInfo)
}

void S_ItemFoodInfo::InitAsDefaultInstance() {
}

S_ItemFoodInfo::S_ItemFoodInfo(const S_ItemFoodInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_ItemFoodInfo)
}

void S_ItemFoodInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_ItemFoodInfo::~S_ItemFoodInfo() {
  // @@protoc_insertion_point(destructor:PublicProto.S_ItemFoodInfo)
  SharedDtor();
}

void S_ItemFoodInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_ItemFoodInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_ItemFoodInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_ItemFoodInfo_descriptor_;
}

const S_ItemFoodInfo& S_ItemFoodInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_ItemFoodInfo* S_ItemFoodInfo::default_instance_ = NULL;

S_ItemFoodInfo* S_ItemFoodInfo::New(::google::protobuf::Arena* arena) const {
  S_ItemFoodInfo* n = new S_ItemFoodInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_ItemFoodInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_ItemFoodInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_ItemFoodInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_ItemFoodInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // required float x = 2;
      case 2: {
        if (tag == 21) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // required float y = 3;
      case 3: {
        if (tag == 29) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_ItemFoodInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_ItemFoodInfo)
  return false;
#undef DO_
}

void S_ItemFoodInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_ItemFoodInfo)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required float x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // required float y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_ItemFoodInfo)
}

::google::protobuf::uint8* S_ItemFoodInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_ItemFoodInfo)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required float x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // required float y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_ItemFoodInfo)
  return target;
}

int S_ItemFoodInfo::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  if (has_x()) {
    // required float x = 2;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int S_ItemFoodInfo::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());

    // required float x = 2;
    total_size += 1 + 4;

    // required float y = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_ItemFoodInfo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_ItemFoodInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_ItemFoodInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_ItemFoodInfo::MergeFrom(const S_ItemFoodInfo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_ItemFoodInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_ItemFoodInfo::CopyFrom(const S_ItemFoodInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ItemFoodInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void S_ItemFoodInfo::Swap(S_ItemFoodInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_ItemFoodInfo::InternalSwap(S_ItemFoodInfo* other) {
  std::swap(id_, other->id_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_ItemFoodInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_ItemFoodInfo_descriptor_;
  metadata.reflection = S_ItemFoodInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_ItemThronInfo::kIdFieldNumber;
const int S_ItemThronInfo::kXFieldNumber;
const int S_ItemThronInfo::kYFieldNumber;
const int S_ItemThronInfo::kRadiusFieldNumber;
#endif  // !_MSC_VER

S_ItemThronInfo::S_ItemThronInfo()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_ItemThronInfo)
}

void S_ItemThronInfo::InitAsDefaultInstance() {
}

S_ItemThronInfo::S_ItemThronInfo(const S_ItemThronInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_ItemThronInfo)
}

void S_ItemThronInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  x_ = 0;
  y_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_ItemThronInfo::~S_ItemThronInfo() {
  // @@protoc_insertion_point(destructor:PublicProto.S_ItemThronInfo)
  SharedDtor();
}

void S_ItemThronInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_ItemThronInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_ItemThronInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_ItemThronInfo_descriptor_;
}

const S_ItemThronInfo& S_ItemThronInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_ItemThronInfo* S_ItemThronInfo::default_instance_ = NULL;

S_ItemThronInfo* S_ItemThronInfo::New(::google::protobuf::Arena* arena) const {
  S_ItemThronInfo* n = new S_ItemThronInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_ItemThronInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_ItemThronInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, radius_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_ItemThronInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_ItemThronInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // required float x = 2;
      case 2: {
        if (tag == 21) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // required float y = 3;
      case 3: {
        if (tag == 29) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_radius;
        break;
      }

      // required int32 radius = 4;
      case 4: {
        if (tag == 32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_ItemThronInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_ItemThronInfo)
  return false;
#undef DO_
}

void S_ItemThronInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_ItemThronInfo)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required float x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // required float y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->y(), output);
  }

  // required int32 radius = 4;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->radius(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_ItemThronInfo)
}

::google::protobuf::uint8* S_ItemThronInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_ItemThronInfo)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required float x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // required float y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->y(), target);
  }

  // required int32 radius = 4;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->radius(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_ItemThronInfo)
  return target;
}

int S_ItemThronInfo::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  if (has_x()) {
    // required float x = 2;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 3;
    total_size += 1 + 4;
  }

  if (has_radius()) {
    // required int32 radius = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->radius());
  }

  return total_size;
}
int S_ItemThronInfo::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());

    // required float x = 2;
    total_size += 1 + 4;

    // required float y = 3;
    total_size += 1 + 4;

    // required int32 radius = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->radius());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_ItemThronInfo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_ItemThronInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_ItemThronInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_ItemThronInfo::MergeFrom(const S_ItemThronInfo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_ItemThronInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_ItemThronInfo::CopyFrom(const S_ItemThronInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ItemThronInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void S_ItemThronInfo::Swap(S_ItemThronInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_ItemThronInfo::InternalSwap(S_ItemThronInfo* other) {
  std::swap(id_, other->id_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(radius_, other->radius_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_ItemThronInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_ItemThronInfo_descriptor_;
  metadata.reflection = S_ItemThronInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_ItemBulletInfo::kIdFieldNumber;
const int S_ItemBulletInfo::kXFieldNumber;
const int S_ItemBulletInfo::kYFieldNumber;
#endif  // !_MSC_VER

S_ItemBulletInfo::S_ItemBulletInfo()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_ItemBulletInfo)
}

void S_ItemBulletInfo::InitAsDefaultInstance() {
}

S_ItemBulletInfo::S_ItemBulletInfo(const S_ItemBulletInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_ItemBulletInfo)
}

void S_ItemBulletInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_ItemBulletInfo::~S_ItemBulletInfo() {
  // @@protoc_insertion_point(destructor:PublicProto.S_ItemBulletInfo)
  SharedDtor();
}

void S_ItemBulletInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_ItemBulletInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_ItemBulletInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_ItemBulletInfo_descriptor_;
}

const S_ItemBulletInfo& S_ItemBulletInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_ItemBulletInfo* S_ItemBulletInfo::default_instance_ = NULL;

S_ItemBulletInfo* S_ItemBulletInfo::New(::google::protobuf::Arena* arena) const {
  S_ItemBulletInfo* n = new S_ItemBulletInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_ItemBulletInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_ItemBulletInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_ItemBulletInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_ItemBulletInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // required float x = 2;
      case 2: {
        if (tag == 21) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // required float y = 3;
      case 3: {
        if (tag == 29) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_ItemBulletInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_ItemBulletInfo)
  return false;
#undef DO_
}

void S_ItemBulletInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_ItemBulletInfo)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required float x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // required float y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_ItemBulletInfo)
}

::google::protobuf::uint8* S_ItemBulletInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_ItemBulletInfo)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required float x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // required float y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_ItemBulletInfo)
  return target;
}

int S_ItemBulletInfo::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  if (has_x()) {
    // required float x = 2;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int S_ItemBulletInfo::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());

    // required float x = 2;
    total_size += 1 + 4;

    // required float y = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_ItemBulletInfo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_ItemBulletInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_ItemBulletInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_ItemBulletInfo::MergeFrom(const S_ItemBulletInfo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_ItemBulletInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_ItemBulletInfo::CopyFrom(const S_ItemBulletInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ItemBulletInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void S_ItemBulletInfo::Swap(S_ItemBulletInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_ItemBulletInfo::InternalSwap(S_ItemBulletInfo* other) {
  std::swap(id_, other->id_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_ItemBulletInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_ItemBulletInfo_descriptor_;
  metadata.reflection = S_ItemBulletInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_ItemCollapsar::kIdFieldNumber;
const int S_ItemCollapsar::kXFieldNumber;
const int S_ItemCollapsar::kYFieldNumber;
const int S_ItemCollapsar::kRadiusFieldNumber;
#endif  // !_MSC_VER

S_ItemCollapsar::S_ItemCollapsar()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_ItemCollapsar)
}

void S_ItemCollapsar::InitAsDefaultInstance() {
}

S_ItemCollapsar::S_ItemCollapsar(const S_ItemCollapsar& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_ItemCollapsar)
}

void S_ItemCollapsar::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  x_ = 0;
  y_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_ItemCollapsar::~S_ItemCollapsar() {
  // @@protoc_insertion_point(destructor:PublicProto.S_ItemCollapsar)
  SharedDtor();
}

void S_ItemCollapsar::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_ItemCollapsar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_ItemCollapsar::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_ItemCollapsar_descriptor_;
}

const S_ItemCollapsar& S_ItemCollapsar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_ItemCollapsar* S_ItemCollapsar::default_instance_ = NULL;

S_ItemCollapsar* S_ItemCollapsar::New(::google::protobuf::Arena* arena) const {
  S_ItemCollapsar* n = new S_ItemCollapsar;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_ItemCollapsar::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_ItemCollapsar*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, radius_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_ItemCollapsar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_ItemCollapsar)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_x;
        break;
      }

      // required float x = 2;
      case 2: {
        if (tag == 21) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_y;
        break;
      }

      // required float y = 3;
      case 3: {
        if (tag == 29) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_radius;
        break;
      }

      // required int32 radius = 5;
      case 5: {
        if (tag == 40) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_ItemCollapsar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_ItemCollapsar)
  return false;
#undef DO_
}

void S_ItemCollapsar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_ItemCollapsar)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required float x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // required float y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->y(), output);
  }

  // required int32 radius = 5;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->radius(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_ItemCollapsar)
}

::google::protobuf::uint8* S_ItemCollapsar::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_ItemCollapsar)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required float x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // required float y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->y(), target);
  }

  // required int32 radius = 5;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->radius(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_ItemCollapsar)
  return target;
}

int S_ItemCollapsar::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_id()) {
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  if (has_x()) {
    // required float x = 2;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 3;
    total_size += 1 + 4;
  }

  if (has_radius()) {
    // required int32 radius = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->radius());
  }

  return total_size;
}
int S_ItemCollapsar::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());

    // required float x = 2;
    total_size += 1 + 4;

    // required float y = 3;
    total_size += 1 + 4;

    // required int32 radius = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->radius());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_ItemCollapsar::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_ItemCollapsar* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_ItemCollapsar*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_ItemCollapsar::MergeFrom(const S_ItemCollapsar& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_ItemCollapsar::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_ItemCollapsar::CopyFrom(const S_ItemCollapsar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ItemCollapsar::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void S_ItemCollapsar::Swap(S_ItemCollapsar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_ItemCollapsar::InternalSwap(S_ItemCollapsar* other) {
  std::swap(id_, other->id_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(radius_, other->radius_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_ItemCollapsar::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_ItemCollapsar_descriptor_;
  metadata.reflection = S_ItemCollapsar_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_SyncSceneInfo::kRolesFieldNumber;
const int S_SyncSceneInfo::kFoodsFieldNumber;
const int S_SyncSceneInfo::kThronsFieldNumber;
const int S_SyncSceneInfo::kBulletsFieldNumber;
const int S_SyncSceneInfo::kCollapsarFieldNumber;
#endif  // !_MSC_VER

S_SyncSceneInfo::S_SyncSceneInfo()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_SyncSceneInfo)
}

void S_SyncSceneInfo::InitAsDefaultInstance() {
}

S_SyncSceneInfo::S_SyncSceneInfo(const S_SyncSceneInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_SyncSceneInfo)
}

void S_SyncSceneInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_SyncSceneInfo::~S_SyncSceneInfo() {
  // @@protoc_insertion_point(destructor:PublicProto.S_SyncSceneInfo)
  SharedDtor();
}

void S_SyncSceneInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_SyncSceneInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_SyncSceneInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_SyncSceneInfo_descriptor_;
}

const S_SyncSceneInfo& S_SyncSceneInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_SyncSceneInfo* S_SyncSceneInfo::default_instance_ = NULL;

S_SyncSceneInfo* S_SyncSceneInfo::New(::google::protobuf::Arena* arena) const {
  S_SyncSceneInfo* n = new S_SyncSceneInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_SyncSceneInfo::Clear() {
  roles_.Clear();
  foods_.Clear();
  throns_.Clear();
  bullets_.Clear();
  collapsar_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_SyncSceneInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_SyncSceneInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .PublicProto.S_ItemRoleInfo roles = 1;
      case 1: {
        if (tag == 10) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_roles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_roles;
        if (input->ExpectTag(18)) goto parse_foods;
        break;
      }

      // repeated .PublicProto.S_ItemFoodInfo foods = 2;
      case 2: {
        if (tag == 18) {
         parse_foods:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_foods()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_foods;
        if (input->ExpectTag(26)) goto parse_throns;
        break;
      }

      // repeated .PublicProto.S_ItemThronInfo throns = 3;
      case 3: {
        if (tag == 26) {
         parse_throns:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_throns()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_throns;
        if (input->ExpectTag(34)) goto parse_bullets;
        break;
      }

      // repeated .PublicProto.S_ItemBulletInfo bullets = 4;
      case 4: {
        if (tag == 34) {
         parse_bullets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bullets()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_bullets;
        if (input->ExpectTag(42)) goto parse_collapsar;
        break;
      }

      // repeated .PublicProto.S_ItemCollapsar collapsar = 5;
      case 5: {
        if (tag == 42) {
         parse_collapsar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_collapsar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_collapsar;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_SyncSceneInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_SyncSceneInfo)
  return false;
#undef DO_
}

void S_SyncSceneInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_SyncSceneInfo)
  // repeated .PublicProto.S_ItemRoleInfo roles = 1;
  for (unsigned int i = 0, n = this->roles_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->roles(i), output);
  }

  // repeated .PublicProto.S_ItemFoodInfo foods = 2;
  for (unsigned int i = 0, n = this->foods_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->foods(i), output);
  }

  // repeated .PublicProto.S_ItemThronInfo throns = 3;
  for (unsigned int i = 0, n = this->throns_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->throns(i), output);
  }

  // repeated .PublicProto.S_ItemBulletInfo bullets = 4;
  for (unsigned int i = 0, n = this->bullets_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->bullets(i), output);
  }

  // repeated .PublicProto.S_ItemCollapsar collapsar = 5;
  for (unsigned int i = 0, n = this->collapsar_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->collapsar(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_SyncSceneInfo)
}

::google::protobuf::uint8* S_SyncSceneInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_SyncSceneInfo)
  // repeated .PublicProto.S_ItemRoleInfo roles = 1;
  for (unsigned int i = 0, n = this->roles_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->roles(i), target);
  }

  // repeated .PublicProto.S_ItemFoodInfo foods = 2;
  for (unsigned int i = 0, n = this->foods_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->foods(i), target);
  }

  // repeated .PublicProto.S_ItemThronInfo throns = 3;
  for (unsigned int i = 0, n = this->throns_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->throns(i), target);
  }

  // repeated .PublicProto.S_ItemBulletInfo bullets = 4;
  for (unsigned int i = 0, n = this->bullets_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->bullets(i), target);
  }

  // repeated .PublicProto.S_ItemCollapsar collapsar = 5;
  for (unsigned int i = 0, n = this->collapsar_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->collapsar(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_SyncSceneInfo)
  return target;
}

int S_SyncSceneInfo::ByteSize() const {
  int total_size = 0;

  // repeated .PublicProto.S_ItemRoleInfo roles = 1;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->roles(i));
  }

  // repeated .PublicProto.S_ItemFoodInfo foods = 2;
  total_size += 1 * this->foods_size();
  for (int i = 0; i < this->foods_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->foods(i));
  }

  // repeated .PublicProto.S_ItemThronInfo throns = 3;
  total_size += 1 * this->throns_size();
  for (int i = 0; i < this->throns_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->throns(i));
  }

  // repeated .PublicProto.S_ItemBulletInfo bullets = 4;
  total_size += 1 * this->bullets_size();
  for (int i = 0; i < this->bullets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bullets(i));
  }

  // repeated .PublicProto.S_ItemCollapsar collapsar = 5;
  total_size += 1 * this->collapsar_size();
  for (int i = 0; i < this->collapsar_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->collapsar(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_SyncSceneInfo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_SyncSceneInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_SyncSceneInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_SyncSceneInfo::MergeFrom(const S_SyncSceneInfo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  roles_.MergeFrom(from.roles_);
  foods_.MergeFrom(from.foods_);
  throns_.MergeFrom(from.throns_);
  bullets_.MergeFrom(from.bullets_);
  collapsar_.MergeFrom(from.collapsar_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_SyncSceneInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_SyncSceneInfo::CopyFrom(const S_SyncSceneInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_SyncSceneInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->roles())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->foods())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->throns())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->bullets())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->collapsar())) return false;
  return true;
}

void S_SyncSceneInfo::Swap(S_SyncSceneInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_SyncSceneInfo::InternalSwap(S_SyncSceneInfo* other) {
  roles_.UnsafeArenaSwap(&other->roles_);
  foods_.UnsafeArenaSwap(&other->foods_);
  throns_.UnsafeArenaSwap(&other->throns_);
  bullets_.UnsafeArenaSwap(&other->bullets_);
  collapsar_.UnsafeArenaSwap(&other->collapsar_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_SyncSceneInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_SyncSceneInfo_descriptor_;
  metadata.reflection = S_SyncSceneInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SceneItemAttr::kIdFieldNumber;
const int SceneItemAttr::kRadiusFieldNumber;
const int SceneItemAttr::kXFieldNumber;
const int SceneItemAttr::kYFieldNumber;
#endif  // !_MSC_VER

SceneItemAttr::SceneItemAttr()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.SceneItemAttr)
}

void SceneItemAttr::InitAsDefaultInstance() {
}

SceneItemAttr::SceneItemAttr(const SceneItemAttr& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.SceneItemAttr)
}

void SceneItemAttr::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  radius_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SceneItemAttr::~SceneItemAttr() {
  // @@protoc_insertion_point(destructor:PublicProto.SceneItemAttr)
  SharedDtor();
}

void SceneItemAttr::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SceneItemAttr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SceneItemAttr::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SceneItemAttr_descriptor_;
}

const SceneItemAttr& SceneItemAttr::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

SceneItemAttr* SceneItemAttr::default_instance_ = NULL;

SceneItemAttr* SceneItemAttr::New(::google::protobuf::Arena* arena) const {
  SceneItemAttr* n = new SceneItemAttr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SceneItemAttr::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SceneItemAttr*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SceneItemAttr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.SceneItemAttr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_radius;
        break;
      }

      // optional int32 radius = 2;
      case 2: {
        if (tag == 16) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_x;
        break;
      }

      // optional float x = 3;
      case 3: {
        if (tag == 29) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_y;
        break;
      }

      // optional float y = 4;
      case 4: {
        if (tag == 37) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.SceneItemAttr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.SceneItemAttr)
  return false;
#undef DO_
}

void SceneItemAttr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.SceneItemAttr)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional int32 radius = 2;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->radius(), output);
  }

  // optional float x = 3;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->x(), output);
  }

  // optional float y = 4;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.SceneItemAttr)
}

::google::protobuf::uint8* SceneItemAttr::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.SceneItemAttr)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional int32 radius = 2;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->radius(), target);
  }

  // optional float x = 3;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->x(), target);
  }

  // optional float y = 4;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.SceneItemAttr)
  return target;
}

int SceneItemAttr::ByteSize() const {
  int total_size = 0;

  // required uint32 id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }
  if (_has_bits_[1 / 32] & 14) {
    // optional int32 radius = 2;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->radius());
    }

    // optional float x = 3;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional float y = 4;
    if (has_y()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SceneItemAttr::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SceneItemAttr* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SceneItemAttr*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SceneItemAttr::MergeFrom(const SceneItemAttr& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SceneItemAttr::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SceneItemAttr::CopyFrom(const SceneItemAttr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SceneItemAttr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SceneItemAttr::Swap(SceneItemAttr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SceneItemAttr::InternalSwap(SceneItemAttr* other) {
  std::swap(id_, other->id_);
  std::swap(radius_, other->radius_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SceneItemAttr::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SceneItemAttr_descriptor_;
  metadata.reflection = SceneItemAttr_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HighSpeedSceneItemAttr::kIdFieldNumber;
const int HighSpeedSceneItemAttr::kRadiusFieldNumber;
const int HighSpeedSceneItemAttr::kXFieldNumber;
const int HighSpeedSceneItemAttr::kYFieldNumber;
#endif  // !_MSC_VER

HighSpeedSceneItemAttr::HighSpeedSceneItemAttr()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.HighSpeedSceneItemAttr)
}

void HighSpeedSceneItemAttr::InitAsDefaultInstance() {
}

HighSpeedSceneItemAttr::HighSpeedSceneItemAttr(const HighSpeedSceneItemAttr& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.HighSpeedSceneItemAttr)
}

void HighSpeedSceneItemAttr::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  radius_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HighSpeedSceneItemAttr::~HighSpeedSceneItemAttr() {
  // @@protoc_insertion_point(destructor:PublicProto.HighSpeedSceneItemAttr)
  SharedDtor();
}

void HighSpeedSceneItemAttr::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HighSpeedSceneItemAttr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HighSpeedSceneItemAttr::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HighSpeedSceneItemAttr_descriptor_;
}

const HighSpeedSceneItemAttr& HighSpeedSceneItemAttr::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

HighSpeedSceneItemAttr* HighSpeedSceneItemAttr::default_instance_ = NULL;

HighSpeedSceneItemAttr* HighSpeedSceneItemAttr::New(::google::protobuf::Arena* arena) const {
  HighSpeedSceneItemAttr* n = new HighSpeedSceneItemAttr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HighSpeedSceneItemAttr::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HighSpeedSceneItemAttr*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HighSpeedSceneItemAttr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.HighSpeedSceneItemAttr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_radius;
        break;
      }

      // optional int32 radius = 2;
      case 2: {
        if (tag == 16) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_x;
        break;
      }

      // optional float x = 3;
      case 3: {
        if (tag == 29) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_y;
        break;
      }

      // optional float y = 4;
      case 4: {
        if (tag == 37) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.HighSpeedSceneItemAttr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.HighSpeedSceneItemAttr)
  return false;
#undef DO_
}

void HighSpeedSceneItemAttr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.HighSpeedSceneItemAttr)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional int32 radius = 2;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->radius(), output);
  }

  // optional float x = 3;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->x(), output);
  }

  // optional float y = 4;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.HighSpeedSceneItemAttr)
}

::google::protobuf::uint8* HighSpeedSceneItemAttr::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.HighSpeedSceneItemAttr)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional int32 radius = 2;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->radius(), target);
  }

  // optional float x = 3;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->x(), target);
  }

  // optional float y = 4;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.HighSpeedSceneItemAttr)
  return target;
}

int HighSpeedSceneItemAttr::ByteSize() const {
  int total_size = 0;

  // required uint32 id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }
  if (_has_bits_[1 / 32] & 14) {
    // optional int32 radius = 2;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->radius());
    }

    // optional float x = 3;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional float y = 4;
    if (has_y()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HighSpeedSceneItemAttr::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const HighSpeedSceneItemAttr* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HighSpeedSceneItemAttr*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HighSpeedSceneItemAttr::MergeFrom(const HighSpeedSceneItemAttr& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HighSpeedSceneItemAttr::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HighSpeedSceneItemAttr::CopyFrom(const HighSpeedSceneItemAttr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HighSpeedSceneItemAttr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HighSpeedSceneItemAttr::Swap(HighSpeedSceneItemAttr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HighSpeedSceneItemAttr::InternalSwap(HighSpeedSceneItemAttr* other) {
  std::swap(id_, other->id_);
  std::swap(radius_, other->radius_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HighSpeedSceneItemAttr::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HighSpeedSceneItemAttr_descriptor_;
  metadata.reflection = HighSpeedSceneItemAttr_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeleteItem::kIdFieldNumber;
const int DeleteItem::kPredatorIdFieldNumber;
#endif  // !_MSC_VER

DeleteItem::DeleteItem()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.DeleteItem)
}

void DeleteItem::InitAsDefaultInstance() {
}

DeleteItem::DeleteItem(const DeleteItem& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.DeleteItem)
}

void DeleteItem::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  predator_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteItem::~DeleteItem() {
  // @@protoc_insertion_point(destructor:PublicProto.DeleteItem)
  SharedDtor();
}

void DeleteItem::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DeleteItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteItem_descriptor_;
}

const DeleteItem& DeleteItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

DeleteItem* DeleteItem::default_instance_ = NULL;

DeleteItem* DeleteItem::New(::google::protobuf::Arena* arena) const {
  DeleteItem* n = new DeleteItem;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DeleteItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, predator_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.DeleteItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_predator_id;
        break;
      }

      // optional uint32 predator_id = 2;
      case 2: {
        if (tag == 16) {
         parse_predator_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &predator_id_)));
          set_has_predator_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.DeleteItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.DeleteItem)
  return false;
#undef DO_
}

void DeleteItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.DeleteItem)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional uint32 predator_id = 2;
  if (has_predator_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->predator_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.DeleteItem)
}

::google::protobuf::uint8* DeleteItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.DeleteItem)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional uint32 predator_id = 2;
  if (has_predator_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->predator_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.DeleteItem)
  return target;
}

int DeleteItem::ByteSize() const {
  int total_size = 0;

  // required uint32 id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }
  // optional uint32 predator_id = 2;
  if (has_predator_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->predator_id());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteItem::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeleteItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteItem::MergeFrom(const DeleteItem& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_predator_id()) {
      set_predator_id(from.predator_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteItem::CopyFrom(const DeleteItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DeleteItem::Swap(DeleteItem* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteItem::InternalSwap(DeleteItem* other) {
  std::swap(id_, other->id_);
  std::swap(predator_id_, other->predator_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteItem_descriptor_;
  metadata.reflection = DeleteItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_SyncLogicCenter::kXFieldNumber;
const int S_SyncLogicCenter::kYFieldNumber;
#endif  // !_MSC_VER

S_SyncLogicCenter::S_SyncLogicCenter()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_SyncLogicCenter)
}

void S_SyncLogicCenter::InitAsDefaultInstance() {
}

S_SyncLogicCenter::S_SyncLogicCenter(const S_SyncLogicCenter& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_SyncLogicCenter)
}

void S_SyncLogicCenter::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_SyncLogicCenter::~S_SyncLogicCenter() {
  // @@protoc_insertion_point(destructor:PublicProto.S_SyncLogicCenter)
  SharedDtor();
}

void S_SyncLogicCenter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_SyncLogicCenter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_SyncLogicCenter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_SyncLogicCenter_descriptor_;
}

const S_SyncLogicCenter& S_SyncLogicCenter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_SyncLogicCenter* S_SyncLogicCenter::default_instance_ = NULL;

S_SyncLogicCenter* S_SyncLogicCenter::New(::google::protobuf::Arena* arena) const {
  S_SyncLogicCenter* n = new S_SyncLogicCenter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_SyncLogicCenter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_SyncLogicCenter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_SyncLogicCenter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_SyncLogicCenter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_SyncLogicCenter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_SyncLogicCenter)
  return false;
#undef DO_
}

void S_SyncLogicCenter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_SyncLogicCenter)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_SyncLogicCenter)
}

::google::protobuf::uint8* S_SyncLogicCenter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_SyncLogicCenter)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_SyncLogicCenter)
  return target;
}

int S_SyncLogicCenter::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
int S_SyncLogicCenter::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_SyncLogicCenter::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_SyncLogicCenter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_SyncLogicCenter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_SyncLogicCenter::MergeFrom(const S_SyncLogicCenter& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_SyncLogicCenter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_SyncLogicCenter::CopyFrom(const S_SyncLogicCenter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_SyncLogicCenter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void S_SyncLogicCenter::Swap(S_SyncLogicCenter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_SyncLogicCenter::InternalSwap(S_SyncLogicCenter* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_SyncLogicCenter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_SyncLogicCenter_descriptor_;
  metadata.reflection = S_SyncLogicCenter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

S_GameOver::S_GameOver()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_GameOver)
}

void S_GameOver::InitAsDefaultInstance() {
}

S_GameOver::S_GameOver(const S_GameOver& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_GameOver)
}

void S_GameOver::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_GameOver::~S_GameOver() {
  // @@protoc_insertion_point(destructor:PublicProto.S_GameOver)
  SharedDtor();
}

void S_GameOver::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_GameOver::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_GameOver::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_GameOver_descriptor_;
}

const S_GameOver& S_GameOver::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_GameOver* S_GameOver::default_instance_ = NULL;

S_GameOver* S_GameOver::New(::google::protobuf::Arena* arena) const {
  S_GameOver* n = new S_GameOver;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_GameOver::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_GameOver::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_GameOver)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_GameOver)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_GameOver)
  return false;
#undef DO_
}

void S_GameOver::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_GameOver)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_GameOver)
}

::google::protobuf::uint8* S_GameOver::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_GameOver)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_GameOver)
  return target;
}

int S_GameOver::ByteSize() const {
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_GameOver::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_GameOver* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_GameOver*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_GameOver::MergeFrom(const S_GameOver& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_GameOver::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_GameOver::CopyFrom(const S_GameOver& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_GameOver::IsInitialized() const {

  return true;
}

void S_GameOver::Swap(S_GameOver* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_GameOver::InternalSwap(S_GameOver* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_GameOver::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_GameOver_descriptor_;
  metadata.reflection = S_GameOver_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int C_Fission::kRadianFieldNumber;
#endif  // !_MSC_VER

C_Fission::C_Fission()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.C_Fission)
}

void C_Fission::InitAsDefaultInstance() {
}

C_Fission::C_Fission(const C_Fission& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.C_Fission)
}

void C_Fission::SharedCtor() {
  _cached_size_ = 0;
  radian_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

C_Fission::~C_Fission() {
  // @@protoc_insertion_point(destructor:PublicProto.C_Fission)
  SharedDtor();
}

void C_Fission::SharedDtor() {
  if (this != default_instance_) {
  }
}

void C_Fission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* C_Fission::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return C_Fission_descriptor_;
}

const C_Fission& C_Fission::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

C_Fission* C_Fission::default_instance_ = NULL;

C_Fission* C_Fission::New(::google::protobuf::Arena* arena) const {
  C_Fission* n = new C_Fission;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void C_Fission::Clear() {
  radian_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool C_Fission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.C_Fission)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float radian = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radian_)));
          set_has_radian();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.C_Fission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.C_Fission)
  return false;
#undef DO_
}

void C_Fission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.C_Fission)
  // required float radian = 1;
  if (has_radian()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->radian(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.C_Fission)
}

::google::protobuf::uint8* C_Fission::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.C_Fission)
  // required float radian = 1;
  if (has_radian()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->radian(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.C_Fission)
  return target;
}

int C_Fission::ByteSize() const {
  int total_size = 0;

  // required float radian = 1;
  if (has_radian()) {
    total_size += 1 + 4;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void C_Fission::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const C_Fission* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const C_Fission*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void C_Fission::MergeFrom(const C_Fission& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_radian()) {
      set_radian(from.radian());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void C_Fission::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void C_Fission::CopyFrom(const C_Fission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Fission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void C_Fission::Swap(C_Fission* other) {
  if (other == this) return;
  InternalSwap(other);
}
void C_Fission::InternalSwap(C_Fission* other) {
  std::swap(radian_, other->radian_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata C_Fission::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = C_Fission_descriptor_;
  metadata.reflection = C_Fission_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int C_Expal::kRadianFieldNumber;
#endif  // !_MSC_VER

C_Expal::C_Expal()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.C_Expal)
}

void C_Expal::InitAsDefaultInstance() {
}

C_Expal::C_Expal(const C_Expal& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.C_Expal)
}

void C_Expal::SharedCtor() {
  _cached_size_ = 0;
  radian_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

C_Expal::~C_Expal() {
  // @@protoc_insertion_point(destructor:PublicProto.C_Expal)
  SharedDtor();
}

void C_Expal::SharedDtor() {
  if (this != default_instance_) {
  }
}

void C_Expal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* C_Expal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return C_Expal_descriptor_;
}

const C_Expal& C_Expal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

C_Expal* C_Expal::default_instance_ = NULL;

C_Expal* C_Expal::New(::google::protobuf::Arena* arena) const {
  C_Expal* n = new C_Expal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void C_Expal::Clear() {
  radian_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool C_Expal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.C_Expal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float radian = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radian_)));
          set_has_radian();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.C_Expal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.C_Expal)
  return false;
#undef DO_
}

void C_Expal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.C_Expal)
  // required float radian = 1;
  if (has_radian()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->radian(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.C_Expal)
}

::google::protobuf::uint8* C_Expal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.C_Expal)
  // required float radian = 1;
  if (has_radian()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->radian(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.C_Expal)
  return target;
}

int C_Expal::ByteSize() const {
  int total_size = 0;

  // required float radian = 1;
  if (has_radian()) {
    total_size += 1 + 4;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void C_Expal::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const C_Expal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const C_Expal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void C_Expal::MergeFrom(const C_Expal& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_radian()) {
      set_radian(from.radian());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void C_Expal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void C_Expal::CopyFrom(const C_Expal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Expal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void C_Expal::Swap(C_Expal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void C_Expal::InternalSwap(C_Expal* other) {
  std::swap(radian_, other->radian_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata C_Expal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = C_Expal_descriptor_;
  metadata.reflection = C_Expal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_UserLogout::kUidFieldNumber;
#endif  // !_MSC_VER

S_UserLogout::S_UserLogout()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_UserLogout)
}

void S_UserLogout::InitAsDefaultInstance() {
}

S_UserLogout::S_UserLogout(const S_UserLogout& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_UserLogout)
}

void S_UserLogout::SharedCtor() {
  _cached_size_ = 0;
  uid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_UserLogout::~S_UserLogout() {
  // @@protoc_insertion_point(destructor:PublicProto.S_UserLogout)
  SharedDtor();
}

void S_UserLogout::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_UserLogout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_UserLogout::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_UserLogout_descriptor_;
}

const S_UserLogout& S_UserLogout::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_UserLogout* S_UserLogout::default_instance_ = NULL;

S_UserLogout* S_UserLogout::New(::google::protobuf::Arena* arena) const {
  S_UserLogout* n = new S_UserLogout;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_UserLogout::Clear() {
  uid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_UserLogout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_UserLogout)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 uid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_UserLogout)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_UserLogout)
  return false;
#undef DO_
}

void S_UserLogout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_UserLogout)
  // required uint64 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_UserLogout)
}

::google::protobuf::uint8* S_UserLogout::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_UserLogout)
  // required uint64 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->uid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_UserLogout)
  return target;
}

int S_UserLogout::ByteSize() const {
  int total_size = 0;

  // required uint64 uid = 1;
  if (has_uid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->uid());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_UserLogout::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_UserLogout* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_UserLogout*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_UserLogout::MergeFrom(const S_UserLogout& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_UserLogout::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_UserLogout::CopyFrom(const S_UserLogout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_UserLogout::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void S_UserLogout::Swap(S_UserLogout* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_UserLogout::InternalSwap(S_UserLogout* other) {
  std::swap(uid_, other->uid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_UserLogout::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_UserLogout_descriptor_;
  metadata.reflection = S_UserLogout_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_SceneItemAttrAfterImpactToCollapsar::kNewPosFieldNumber;
const int S_SceneItemAttrAfterImpactToCollapsar::kCollapsarIdFieldNumber;
const int S_SceneItemAttrAfterImpactToCollapsar::kUidFieldNumber;
const int S_SceneItemAttrAfterImpactToCollapsar::kEraseCollapsarFieldNumber;
#endif  // !_MSC_VER

S_SceneItemAttrAfterImpactToCollapsar::S_SceneItemAttrAfterImpactToCollapsar()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
}

void S_SceneItemAttrAfterImpactToCollapsar::InitAsDefaultInstance() {
}

S_SceneItemAttrAfterImpactToCollapsar::S_SceneItemAttrAfterImpactToCollapsar(const S_SceneItemAttrAfterImpactToCollapsar& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
}

void S_SceneItemAttrAfterImpactToCollapsar::SharedCtor() {
  _cached_size_ = 0;
  collapsar_id_ = 0u;
  uid_ = GOOGLE_ULONGLONG(0);
  erase_collapsar_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_SceneItemAttrAfterImpactToCollapsar::~S_SceneItemAttrAfterImpactToCollapsar() {
  // @@protoc_insertion_point(destructor:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  SharedDtor();
}

void S_SceneItemAttrAfterImpactToCollapsar::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_SceneItemAttrAfterImpactToCollapsar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_SceneItemAttrAfterImpactToCollapsar::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_SceneItemAttrAfterImpactToCollapsar_descriptor_;
}

const S_SceneItemAttrAfterImpactToCollapsar& S_SceneItemAttrAfterImpactToCollapsar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_SceneItemAttrAfterImpactToCollapsar* S_SceneItemAttrAfterImpactToCollapsar::default_instance_ = NULL;

S_SceneItemAttrAfterImpactToCollapsar* S_SceneItemAttrAfterImpactToCollapsar::New(::google::protobuf::Arena* arena) const {
  S_SceneItemAttrAfterImpactToCollapsar* n = new S_SceneItemAttrAfterImpactToCollapsar;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_SceneItemAttrAfterImpactToCollapsar::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<S_SceneItemAttrAfterImpactToCollapsar*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(uid_, erase_collapsar_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  new_pos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_SceneItemAttrAfterImpactToCollapsar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .PublicProto.SceneItemAttr new_pos = 1;
      case 1: {
        if (tag == 10) {
         parse_new_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_new_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_new_pos;
        if (input->ExpectTag(16)) goto parse_collapsar_id;
        break;
      }

      // required uint32 collapsar_id = 2;
      case 2: {
        if (tag == 16) {
         parse_collapsar_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &collapsar_id_)));
          set_has_collapsar_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_uid;
        break;
      }

      // required uint64 uid = 3;
      case 3: {
        if (tag == 24) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_erase_collapsar;
        break;
      }

      // required bool erase_collapsar = 4;
      case 4: {
        if (tag == 32) {
         parse_erase_collapsar:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &erase_collapsar_)));
          set_has_erase_collapsar();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  return false;
#undef DO_
}

void S_SceneItemAttrAfterImpactToCollapsar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  // repeated .PublicProto.SceneItemAttr new_pos = 1;
  for (unsigned int i = 0, n = this->new_pos_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->new_pos(i), output);
  }

  // required uint32 collapsar_id = 2;
  if (has_collapsar_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->collapsar_id(), output);
  }

  // required uint64 uid = 3;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->uid(), output);
  }

  // required bool erase_collapsar = 4;
  if (has_erase_collapsar()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->erase_collapsar(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
}

::google::protobuf::uint8* S_SceneItemAttrAfterImpactToCollapsar::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  // repeated .PublicProto.SceneItemAttr new_pos = 1;
  for (unsigned int i = 0, n = this->new_pos_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->new_pos(i), target);
  }

  // required uint32 collapsar_id = 2;
  if (has_collapsar_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->collapsar_id(), target);
  }

  // required uint64 uid = 3;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->uid(), target);
  }

  // required bool erase_collapsar = 4;
  if (has_erase_collapsar()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->erase_collapsar(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_SceneItemAttrAfterImpactToCollapsar)
  return target;
}

int S_SceneItemAttrAfterImpactToCollapsar::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_collapsar_id()) {
    // required uint32 collapsar_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->collapsar_id());
  }

  if (has_uid()) {
    // required uint64 uid = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->uid());
  }

  if (has_erase_collapsar()) {
    // required bool erase_collapsar = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
int S_SceneItemAttrAfterImpactToCollapsar::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required uint32 collapsar_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->collapsar_id());

    // required uint64 uid = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->uid());

    // required bool erase_collapsar = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .PublicProto.SceneItemAttr new_pos = 1;
  total_size += 1 * this->new_pos_size();
  for (int i = 0; i < this->new_pos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->new_pos(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_SceneItemAttrAfterImpactToCollapsar::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_SceneItemAttrAfterImpactToCollapsar* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_SceneItemAttrAfterImpactToCollapsar*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_SceneItemAttrAfterImpactToCollapsar::MergeFrom(const S_SceneItemAttrAfterImpactToCollapsar& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  new_pos_.MergeFrom(from.new_pos_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_collapsar_id()) {
      set_collapsar_id(from.collapsar_id());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_erase_collapsar()) {
      set_erase_collapsar(from.erase_collapsar());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_SceneItemAttrAfterImpactToCollapsar::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_SceneItemAttrAfterImpactToCollapsar::CopyFrom(const S_SceneItemAttrAfterImpactToCollapsar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_SceneItemAttrAfterImpactToCollapsar::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->new_pos())) return false;
  return true;
}

void S_SceneItemAttrAfterImpactToCollapsar::Swap(S_SceneItemAttrAfterImpactToCollapsar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_SceneItemAttrAfterImpactToCollapsar::InternalSwap(S_SceneItemAttrAfterImpactToCollapsar* other) {
  new_pos_.UnsafeArenaSwap(&other->new_pos_);
  std::swap(collapsar_id_, other->collapsar_id_);
  std::swap(uid_, other->uid_);
  std::swap(erase_collapsar_, other->erase_collapsar_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_SceneItemAttrAfterImpactToCollapsar::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_SceneItemAttrAfterImpactToCollapsar_descriptor_;
  metadata.reflection = S_SceneItemAttrAfterImpactToCollapsar_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int S_UpdatePoint::kPointFieldNumber;
#endif  // !_MSC_VER

S_UpdatePoint::S_UpdatePoint()
  : ::google::protobuf::Message() , _internal_metadata_(NULL)  {
  SharedCtor();
  // @@protoc_insertion_point(constructor:PublicProto.S_UpdatePoint)
}

void S_UpdatePoint::InitAsDefaultInstance() {
}

S_UpdatePoint::S_UpdatePoint(const S_UpdatePoint& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:PublicProto.S_UpdatePoint)
}

void S_UpdatePoint::SharedCtor() {
  _cached_size_ = 0;
  point_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

S_UpdatePoint::~S_UpdatePoint() {
  // @@protoc_insertion_point(destructor:PublicProto.S_UpdatePoint)
  SharedDtor();
}

void S_UpdatePoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void S_UpdatePoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* S_UpdatePoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return S_UpdatePoint_descriptor_;
}

const S_UpdatePoint& S_UpdatePoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();
  return *default_instance_;
}

S_UpdatePoint* S_UpdatePoint::default_instance_ = NULL;

S_UpdatePoint* S_UpdatePoint::New(::google::protobuf::Arena* arena) const {
  S_UpdatePoint* n = new S_UpdatePoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void S_UpdatePoint::Clear() {
  point_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool S_UpdatePoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PublicProto.S_UpdatePoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 point = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &point_)));
          set_has_point();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PublicProto.S_UpdatePoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PublicProto.S_UpdatePoint)
  return false;
#undef DO_
}

void S_UpdatePoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PublicProto.S_UpdatePoint)
  // required uint32 point = 1;
  if (has_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->point(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:PublicProto.S_UpdatePoint)
}

::google::protobuf::uint8* S_UpdatePoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:PublicProto.S_UpdatePoint)
  // required uint32 point = 1;
  if (has_point()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->point(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PublicProto.S_UpdatePoint)
  return target;
}

int S_UpdatePoint::ByteSize() const {
  int total_size = 0;

  // required uint32 point = 1;
  if (has_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->point());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void S_UpdatePoint::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const S_UpdatePoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const S_UpdatePoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void S_UpdatePoint::MergeFrom(const S_UpdatePoint& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_point()) {
      set_point(from.point());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void S_UpdatePoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void S_UpdatePoint::CopyFrom(const S_UpdatePoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_UpdatePoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void S_UpdatePoint::Swap(S_UpdatePoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void S_UpdatePoint::InternalSwap(S_UpdatePoint* other) {
  std::swap(point_, other->point_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata S_UpdatePoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = S_UpdatePoint_descriptor_;
  metadata.reflection = S_UpdatePoint_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PublicProto

// @@protoc_insertion_point(global_scope)
